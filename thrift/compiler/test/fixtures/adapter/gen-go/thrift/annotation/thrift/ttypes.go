// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package thrift

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

var GoUnusedProtection__ int;

// Indicates a definition/feature should only be used with permission, may
// only work in specific contexts, and may change in incompatible ways without
// notice.
type Experimental struct {
}

func NewExperimental() *Experimental {
  return &Experimental{}
}

type ExperimentalBuilder struct {
  obj *Experimental
}

func NewExperimentalBuilder() *ExperimentalBuilder{
  return &ExperimentalBuilder{
    obj: NewExperimental(),
  }
}

func (p ExperimentalBuilder) Emit() *Experimental{
  return &Experimental{
  }
}

func (p *Experimental) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Experimental) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Experimental"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Experimental) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Experimental({})")
}

// Annotate a thrift structured or enum to indicate if ids or values should not
// be used.
// 
// For example, you may want to mark ids as deprecated, or these ids
// might be reserved for other use cases or annotations.
// 
// The resolved set of disallowed ids is the union of the values in `ids` and
// the range of values represented in `id_ranges`. Example:
// 
//  // These ids are not allowed: 3, 8, half-open ranges [10, 15), [20, 30)
//  @thrift.ReserveIds{ids = [3, 8], id_ranges = {10: 15, 20: 30}}
//  struct Foo {
//    ...
//    3: i64 f; // Build failure: 3 cannot be used
//  }
// 
// Attributes:
//  - Ids: Individual ids that cannot be used.
//  - IdRanges: Represents ranges of ids that cannot be used.
// 
// Each (key: value) pair represents the half-open range `[key, value)`,
// where `key` is included and `value` is not. For example, the map
// `{10: 15, 20: 30}` represents the union of id/value ranges `[10, 15)` and
// `[20, 30)`.
type ReserveIds struct {
  Ids []int32 `thrift:"ids,1" db:"ids" json:"ids"`
  IdRanges map[int32]int32 `thrift:"id_ranges,2" db:"id_ranges" json:"id_ranges"`
}

func NewReserveIds() *ReserveIds {
  return &ReserveIds{}
}


func (p *ReserveIds) GetIds() []int32 {
  return p.Ids
}

func (p *ReserveIds) GetIdRanges() map[int32]int32 {
  return p.IdRanges
}
type ReserveIdsBuilder struct {
  obj *ReserveIds
}

func NewReserveIdsBuilder() *ReserveIdsBuilder{
  return &ReserveIdsBuilder{
    obj: NewReserveIds(),
  }
}

func (p ReserveIdsBuilder) Emit() *ReserveIds{
  return &ReserveIds{
    Ids: p.obj.Ids,
    IdRanges: p.obj.IdRanges,
  }
}

func (r *ReserveIdsBuilder) Ids(ids []int32) *ReserveIdsBuilder {
  r.obj.Ids = ids
  return r
}

func (r *ReserveIdsBuilder) IdRanges(idRanges map[int32]int32) *ReserveIdsBuilder {
  r.obj.IdRanges = idRanges
  return r
}

func (r *ReserveIds) SetIds(ids []int32) *ReserveIds {
  r.Ids = ids
  return r
}

func (r *ReserveIds) SetIdRanges(idRanges map[int32]int32) *ReserveIds {
  r.IdRanges = idRanges
  return r
}

func (p *ReserveIds) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReserveIds)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.Ids =  tSlice
  for i := 0; i < size; i ++ {
    var _elem0 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _elem0 = v
    }
    p.Ids = append(p.Ids, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ReserveIds)  ReadField2(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32]int32, size)
  p.IdRanges =  tMap
  for i := 0; i < size; i ++ {
    var _key1 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _key1 = v
    }
    var _val2 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _val2 = v
    }
    p.IdRanges[_key1] = _val2
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ReserveIds) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("ReserveIds"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := p.writeField2(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReserveIds) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("ids", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ids: ", p), err) }
  if err := oprot.WriteListBegin(thrift.I32, len(p.Ids)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Ids {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ids: ", p), err) }
  return err
}

func (p *ReserveIds) writeField2(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("id_ranges", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id_ranges: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(p.IdRanges)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.IdRanges {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id_ranges: ", p), err) }
  return err
}

func (p *ReserveIds) String() string {
  if p == nil {
    return "<nil>"
  }

  idsVal := fmt.Sprintf("%v", p.Ids)
  idRangesVal := fmt.Sprintf("%v", p.IdRanges)
  return fmt.Sprintf("ReserveIds({Ids:%s IdRanges:%s})", idsVal, idRangesVal)
}

// Indicates additional backward compatibility restrictions, beyond the
// standard Thrift required 'wire' compatibility.
// 
// Attributes:
//  - FieldName
type RequiresBackwardCompatibility struct {
  FieldName bool `thrift:"field_name,1" db:"field_name" json:"field_name"`
}

func NewRequiresBackwardCompatibility() *RequiresBackwardCompatibility {
  return &RequiresBackwardCompatibility{}
}


func (p *RequiresBackwardCompatibility) GetFieldName() bool {
  return p.FieldName
}
type RequiresBackwardCompatibilityBuilder struct {
  obj *RequiresBackwardCompatibility
}

func NewRequiresBackwardCompatibilityBuilder() *RequiresBackwardCompatibilityBuilder{
  return &RequiresBackwardCompatibilityBuilder{
    obj: NewRequiresBackwardCompatibility(),
  }
}

func (p RequiresBackwardCompatibilityBuilder) Emit() *RequiresBackwardCompatibility{
  return &RequiresBackwardCompatibility{
    FieldName: p.obj.FieldName,
  }
}

func (r *RequiresBackwardCompatibilityBuilder) FieldName(fieldName bool) *RequiresBackwardCompatibilityBuilder {
  r.obj.FieldName = fieldName
  return r
}

func (r *RequiresBackwardCompatibility) SetFieldName(fieldName bool) *RequiresBackwardCompatibility {
  r.FieldName = fieldName
  return r
}

func (p *RequiresBackwardCompatibility) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RequiresBackwardCompatibility)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadBool(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.FieldName = v
  }
  return nil
}

func (p *RequiresBackwardCompatibility) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("RequiresBackwardCompatibility"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RequiresBackwardCompatibility) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("field_name", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_name: ", p), err) }
  if err := oprot.WriteBool(bool(p.FieldName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field_name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_name: ", p), err) }
  return err
}

func (p *RequiresBackwardCompatibility) String() string {
  if p == nil {
    return "<nil>"
  }

  fieldNameVal := fmt.Sprintf("%v", p.FieldName)
  return fmt.Sprintf("RequiresBackwardCompatibility({FieldName:%s})", fieldNameVal)
}

// An annotation that changes the field qualifier from 'none' to 'terse'.
// A terse field is eligible to skip serialization, when it equals to the
// intrinsic default value. It also clears to the intrinsic default value
// before deserialization to distinguish between if a terse field was skipped
// or missing during serialization. This is different from an unqualified
// field, as an unqualified field is always serialized regardless of its value,
// and it is not cleared before deserialization.
// 
// The annotation can be only used to annotate an unqualified field, and when
// it is annotating a struct or exception, it changes all unqualified fields to
// terse fields. Note, the annotation can not be used for union.
type TerseWrite struct {
}

func NewTerseWrite() *TerseWrite {
  return &TerseWrite{}
}

type TerseWriteBuilder struct {
  obj *TerseWrite
}

func NewTerseWriteBuilder() *TerseWriteBuilder{
  return &TerseWriteBuilder{
    obj: NewTerseWrite(),
  }
}

func (p TerseWriteBuilder) Emit() *TerseWrite{
  return &TerseWrite{
  }
}

func (p *TerseWrite) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TerseWrite) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("TerseWrite"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TerseWrite) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("TerseWrite({})")
}

// Indicates that a field's value should never be stored on the stack.
type Box struct {
}

func NewBox() *Box {
  return &Box{}
}

type BoxBuilder struct {
  obj *Box
}

func NewBoxBuilder() *BoxBuilder{
  return &BoxBuilder{
    obj: NewBox(),
  }
}

func (p BoxBuilder) Emit() *Box{
  return &Box{
  }
}

func (p *Box) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Box) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Box"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Box) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Box({})")
}

type Mixin struct {
}

func NewMixin() *Mixin {
  return &Mixin{}
}

type MixinBuilder struct {
  obj *Mixin
}

func NewMixinBuilder() *MixinBuilder{
  return &MixinBuilder{
    obj: NewMixin(),
  }
}

func (p MixinBuilder) Emit() *Mixin{
  return &Mixin{
  }
}

func (p *Mixin) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Mixin) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Mixin"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Mixin) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Mixin({})")
}

// Option to serialize thrift struct in ascending field id order.
// 
// This can potentially make serialized data size smaller in compact protocol,
// since compact protocol can write deltas between subsequent field ids.
type SerializeInFieldIdOrder struct {
}

func NewSerializeInFieldIdOrder() *SerializeInFieldIdOrder {
  return &SerializeInFieldIdOrder{}
}

type SerializeInFieldIdOrderBuilder struct {
  obj *SerializeInFieldIdOrder
}

func NewSerializeInFieldIdOrderBuilder() *SerializeInFieldIdOrderBuilder{
  return &SerializeInFieldIdOrderBuilder{
    obj: NewSerializeInFieldIdOrder(),
  }
}

func (p SerializeInFieldIdOrderBuilder) Emit() *SerializeInFieldIdOrder{
  return &SerializeInFieldIdOrder{
  }
}

func (p *SerializeInFieldIdOrder) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SerializeInFieldIdOrder) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("SerializeInFieldIdOrder"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SerializeInFieldIdOrder) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("SerializeInFieldIdOrder({})")
}

// Indicates an enum is a bitmask and should support bit-wise operators.
type BitmaskEnum struct {
}

func NewBitmaskEnum() *BitmaskEnum {
  return &BitmaskEnum{}
}

type BitmaskEnumBuilder struct {
  obj *BitmaskEnum
}

func NewBitmaskEnumBuilder() *BitmaskEnumBuilder{
  return &BitmaskEnumBuilder{
    obj: NewBitmaskEnum(),
  }
}

func (p BitmaskEnumBuilder) Emit() *BitmaskEnum{
  return &BitmaskEnum{
  }
}

func (p *BitmaskEnum) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *BitmaskEnum) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("BitmaskEnum"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BitmaskEnum) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("BitmaskEnum({})")
}

// Specifies the field where the exception message is stored. The field
// is used to generate an additional method to get it.
// 
// Attributes:
//  - Field
type ExceptionMessage struct {
  Field string `thrift:"field,1" db:"field" json:"field"`
}

func NewExceptionMessage() *ExceptionMessage {
  return &ExceptionMessage{}
}


func (p *ExceptionMessage) GetField() string {
  return p.Field
}
type ExceptionMessageBuilder struct {
  obj *ExceptionMessage
}

func NewExceptionMessageBuilder() *ExceptionMessageBuilder{
  return &ExceptionMessageBuilder{
    obj: NewExceptionMessage(),
  }
}

func (p ExceptionMessageBuilder) Emit() *ExceptionMessage{
  return &ExceptionMessage{
    Field: p.obj.Field,
  }
}

func (e *ExceptionMessageBuilder) Field(field string) *ExceptionMessageBuilder {
  e.obj.Field = field
  return e
}

func (e *ExceptionMessage) SetField(field string) *ExceptionMessage {
  e.Field = field
  return e
}

func (p *ExceptionMessage) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ExceptionMessage)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Field = v
  }
  return nil
}

func (p *ExceptionMessage) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("ExceptionMessage"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ExceptionMessage) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field: ", p), err) }
  if err := oprot.WriteString(string(p.Field)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field: ", p), err) }
  return err
}

func (p *ExceptionMessage) String() string {
  if p == nil {
    return "<nil>"
  }

  fieldVal := fmt.Sprintf("%v", p.Field)
  return fmt.Sprintf("ExceptionMessage({Field:%s})", fieldVal)
}

// Generates a const of type schema. Struct containing the schema of the
// annotated type. Optionally specify name to override default
// schema<structName>.
// 
// Attributes:
//  - Name
type GenerateRuntimeSchema struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewGenerateRuntimeSchema() *GenerateRuntimeSchema {
  return &GenerateRuntimeSchema{}
}


func (p *GenerateRuntimeSchema) GetName() string {
  return p.Name
}
type GenerateRuntimeSchemaBuilder struct {
  obj *GenerateRuntimeSchema
}

func NewGenerateRuntimeSchemaBuilder() *GenerateRuntimeSchemaBuilder{
  return &GenerateRuntimeSchemaBuilder{
    obj: NewGenerateRuntimeSchema(),
  }
}

func (p GenerateRuntimeSchemaBuilder) Emit() *GenerateRuntimeSchema{
  return &GenerateRuntimeSchema{
    Name: p.obj.Name,
  }
}

func (g *GenerateRuntimeSchemaBuilder) Name(name string) *GenerateRuntimeSchemaBuilder {
  g.obj.Name = name
  return g
}

func (g *GenerateRuntimeSchema) SetName(name string) *GenerateRuntimeSchema {
  g.Name = name
  return g
}

func (p *GenerateRuntimeSchema) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GenerateRuntimeSchema)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *GenerateRuntimeSchema) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("GenerateRuntimeSchema"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GenerateRuntimeSchema) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *GenerateRuntimeSchema) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  return fmt.Sprintf("GenerateRuntimeSchema({Name:%s})", nameVal)
}

// Indicates that a field's value should never be stored on the stack, and that
// identical values can be shared in immutable contexts.
type InternBox struct {
}

func NewInternBox() *InternBox {
  return &InternBox{}
}

type InternBoxBuilder struct {
  obj *InternBox
}

func NewInternBoxBuilder() *InternBoxBuilder{
  return &InternBoxBuilder{
    obj: NewInternBox(),
  }
}

func (p InternBoxBuilder) Emit() *InternBox{
  return &InternBox{
  }
}

func (p *InternBox) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *InternBox) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("InternBox"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InternBox) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("InternBox({})")
}

